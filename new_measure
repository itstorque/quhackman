class quantum_simulation():
    def __init__(self):
        self.gates1 = []
        self.gates2 = []        
        self.qc = QuantumCircuit(2, 2)
        self.qc.h(0)
        self.qc.cx(0,1)
        self.output = []
        self.winner_idx = -1
        self.results = -1
    def load_gates(self):
        for i in range(len(self.gates1)):
            if self.gates1[i] == 'T':
                self.qc.rx(np.pi/4,0)
            elif self.gates1[i] == 'S':
                self.qc.rx(np.pi/2,0)
        for i in range(len(self.gates2)):
            if self.gates2[i] == 'T':
                self.qc.rx(np.pi/4,1)
            elif self.gates2[i] == 'S':
                self.qc.rx(np.pi/2,1)
    def run(self):
        self.qc.measure([0,1],[1,0])
        # Execute the circuit on the qasm simulator
        job = execute(self.qc, simulator, shots=1000)
        # Grab results from the job
        result = job.result()
        # Returns counts
        counts = result.get_counts(self.qc)
        print("\nTotal count for 00 and 11 are:",counts)
        self.output = counts
        
        
    def measure(self,ra,rb,measure_index):
        self.qc = QuantumCircuit(2, 1)
        self.qc.h(0)
        self.qc.cx(0,1)
        self.qc.rx(ra,0)
        self.qc.rx(rb,0)
        self.qc.measure([measure_index],[0])
        job = execute(self.qc, simulator, shots=1)
        # Grab results from the job
        result = job.result()
        # Returns counts
        counts = result.get_counts(self.qc)
        counts.setdefault('0',0)
        counts.setdefault('1',0)
        zero_counts = (counts['0'])
        one_counts = (counts['1'])
        print(zero_counts,one_counts)
        self.results = zero_counts
        #self.results = 
        #if zero_counts >= one_counts:
        #    self.output = 0
        #else:
        #    self.output = 
            
